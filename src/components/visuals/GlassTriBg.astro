---
/**
 * GlassTriBg (SSR version, no JS)
 * - Renders layered translucent triangles server-side
 * - Subtle parallax via CSS animations (still “dynamic”)
 * - No client <script>, so it can’t be blocked by CSP or hydration
 *
 * Props:
 *   primary?: string   // top blue (default #0E5BAF)
 *   secondary?: string // mid blue (default #7EC3F2)
 *   density?: number   // 0.5–1.6 (more = more triangles). Default 1.35
 *   seed?: number      // change to shuffle the pattern (default 42)
 */
interface Props {
  primary?: string;
  secondary?: string;
  density?: number;
  seed?: number;
}
const {
  primary = '#0E5BAF',
  secondary = '#7EC3F2',
  density = 1.35,
  seed = 42,
} = Astro.props as Props;

const BASE_W = 1440, BASE_H = 900;
const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
const D = clamp(density, 0.5, 1.6);

// Simple deterministic RNG
function prng(s: number) {
  let x = Math.sin(s) * 10000;
  return () => {
    x = Math.sin(x) * 10000;
    return x - Math.floor(x);
  };
}
function triPoints(cx: number, cy: number, size: number, r1: number, r2: number) {
  const a1 = r1 * Math.PI * 2, a2 = (r1 + 0.33) * Math.PI * 2, a3 = (r1 + 0.67) * Math.PI * 2;
  const j = 0.35 + r2 * 0.25; // asymmetry for “glass” feel
  const p1 = [cx + Math.cos(a1) * size,      cy + Math.sin(a1) * size * j];
  const p2 = [cx + Math.cos(a2) * size * j,  cy + Math.sin(a2) * size];
  const p3 = [cx + Math.cos(a3) * size,      cy + Math.sin(a3) * size];
  return `${p1[0].toFixed(1)},${p1[1].toFixed(1)} ${p2[0].toFixed(1)},${p2[1].toFixed(1)} ${p3[0].toFixed(1)},${p3[1].toFixed(1)}`;
}

type Area = [number, number, number, number]; // [x0,y0,x1,y1] relative (0..1)
function makeLayer(countBase: number, area: Area, s: number) {
  const rnd = prng(s);
  const [rx0, ry0, rx1, ry1] = area;
  const x0 = rx0 * BASE_W, y0 = ry0 * BASE_H;
  const x1 = rx1 * BASE_W, y1 = ry1 * BASE_H;
  const count = Math.round(countBase * D);

  return Array.from({ length: count }, (_, i) => {
    const r1 = rnd(), r2 = rnd(), r3 = rnd();
    const cx = x0 + r1 * (x1 - x0);
    const cy = y0 + r2 * (y1 - y0);
    const size = 70 + r3 * 190;
    const opacity = (0.36 + rnd() * 0.28).toFixed(2); // 0.36–0.64
    return {
      points: triPoints(cx, cy, size, r1, r2),
      opacity,
    };
  });
}

// Define five bands like the reference image
const L1 = makeLayer(18, [0.00, 0.00, 1.00, 0.42], seed * 1.1);
const L2 = makeLayer(24, [0.00, 0.10, 1.00, 0.55], seed * 2.2);
const L3 = makeLayer(26, [0.00, 0.22, 1.00, 0.75], seed * 3.3);
const L4 = makeLayer(24, [0.10, 0.36, 0.90, 0.95], seed * 4.4);
const L5 = makeLayer(22, [0.05, 0.50, 0.95, 1.05], seed * 5.5);
---

<style>
  .bg-root {
    position: fixed;
    inset: 0;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
  }
  .wrap {
    position: absolute;
    inset: -2%;
    transform: scale(1.04); /* bleed to avoid edge gaps */
  }

  .fade-bottom {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      rgba(255,255,255,0) 30%,
      rgba(255,255,255,0.75) 78%,
      #fff 100%
    );
  }
  @media (prefers-color-scheme: dark) {
    .fade-bottom {
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,0) 32%,
        rgba(0,0,0,0.55) 84%,
        rgba(0,0,0,0.85) 100%
      );
    }
  }

  /* Motion without JS */
  .layer { animation: drift 32s ease-in-out infinite; transform-origin: 50% 0%; }
  .l2 { animation-duration: 38s; animation-direction: reverse; }
  .l3 { animation-duration: 44s; }
  .l4 { animation-duration: 52s; animation-direction: reverse; }
  .l5 { animation-duration: 60s; }

  @keyframes drift {
    0%   { transform: translateY(0px)   translateX(0px)   rotate(0deg)   scale(1.00); }
    50%  { transform: translateY(-28px) translateX(14px)  rotate(0.6deg) scale(1.01); }
    100% { transform: translateY(0px)   translateX(0px)   rotate(0deg)   scale(1.00); }
  }
</style>

<div class="bg-root">
  <div class="wrap">
    <svg
      width="100%" height="100%"
      viewBox={`0 0 ${BASE_W} ${BASE_H}`}
      preserveAspectRatio="xMidYMid slice"
      xmlns="http://www.w3.org/2000/svg">

      <defs>
        <!-- Top blue wash -->
        <linearGradient id="sky" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%"  stop-color={primary}   stop-opacity="0.55"/>
          <stop offset="28%" stop-color={secondary} stop-opacity="0.22"/>
          <stop offset="58%" stop-color="#ffffff"   stop-opacity="0.06"/>
          <stop offset="100%" stop-color="#ffffff"  stop-opacity="0"/>
        </linearGradient>

        <!-- Slightly higher contrast so triangles read -->
        <linearGradient id="polyfill" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%"   stop-color={primary}   stop-opacity="0.18"/>
          <stop offset="55%"  stop-color={secondary} stop-opacity="0.14"/>
          <stop offset="100%" stop-color="#ffffff"   stop-opacity="0.10"/>
        </linearGradient>
      </defs>

      <!-- background wash -->
      <rect x="0" y="0" width={BASE_W} height={BASE_H} fill="url(#sky)" />

      <!-- five animated layers -->
      <g class="layer l1">
        {L1.map((p) => <polygon fill="url(#polyfill)" points={p.points} opacity={p.opacity} stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />)}
      </g>
      <g class="layer l2">
        {L2.map((p) => <polygon fill="url(#polyfill)" points={p.points} opacity={p.opacity} stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />)}
      </g>
      <g class="layer l3">
        {L3.map((p) => <polygon fill="url(#polyfill)" points={p.points} opacity={p.opacity} stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />)}
      </g>
      <g class="layer l4">
        {L4.map((p) => <polygon fill="url(#polyfill)" points={p.points} opacity={p.opacity} stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />)}
      </g>
      <g class="layer l5">
        {L5.map((p) => <polygon fill="url(#polyfill)" points={p.points} opacity={p.opacity} stroke="rgba(255,255,255,0.08)" stroke-width="0.5" />)}
      </g>
    </svg>
  </div>

  <div class="fade-bottom"></div>
</div>

